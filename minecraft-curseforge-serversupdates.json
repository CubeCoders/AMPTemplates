[
    {
        "UpdateStageName": "Ensure Minecraft Directory",
        "UpdateSourcePlatform": "Windows",
        "UpdateSource": "Executable",
        "UpdateSourceData": "cmd.exe",
        "UpdateSourceArgs": "/C if not exist Minecraft mkdir Minecraft"
    },
    {
        "UpdateStageName": "Ensure Minecraft Directory",
        "UpdateSourcePlatform": "Linux",
        "UpdateSource": "Executable",
        "UpdateSourceData": "/bin/bash",
        "UpdateSourceArgs": "-c \"mkdir -p Minecraft\""
    },
    {
        "UpdateStageName": "Refresh CurseForge Catalogue",
        "UpdateSourcePlatform": "Linux",
        "UpdateSource": "Executable",
        "UpdateSourceData": "/bin/bash",
        "UpdateSourceArgs": "-c \"set -euo pipefail; API_KEY='{{CurseForgeApiKey}}'; if [[ -z \"$API_KEY\" ]]; then     echo 'CurseForge API key is required (CurseForgeApiKey setting).' >&2;     exit 1; fi; PAGE_SIZE='{{CurseForgePageSize}}'; if ! [[ $PAGE_SIZE =~ ^[0-9]+$ ]] || [[ $PAGE_SIZE -lt 1 || $PAGE_SIZE -gt 100 ]]; then     PAGE_SIZE=50; fi; MAX_PAGES='{{CurseForgeMaxPages}}'; if ! [[ $MAX_PAGES =~ ^[0-9]+$ ]] || [[ $MAX_PAGES -lt 1 || $MAX_PAGES -gt 40 ]]; then     MAX_PAGES=5; fi; MOD_LOADER='{{CurseForgeModLoaderType}}'; GAME_VERSION_TYPE='{{CurseForgeGameVersionType}}'; BASE_URL='https://api.curseforge.com/v1/mods/search?gameId=432&classId=4471&sortOrder=desc'; if [[ -n \"$GAME_VERSION_TYPE\" && $GAME_VERSION_TYPE != 0 ]]; then     BASE_URL+=\"&gameVersionTypeId=$GAME_VERSION_TYPE\"; fi; if [[ -n \"$MOD_LOADER\" && $MOD_LOADER != 0 ]]; then     BASE_URL+=\"&modLoaderType=$MOD_LOADER\"; fi; TEMP=$(mktemp); trap 'rm -f \"$TEMP\"' EXIT; PAGES=0; for (( PAGE=0; PAGE<MAX_PAGES; PAGE++ )); do     URL=\"$BASE_URL&pageSize=$PAGE_SIZE&page=$PAGE\";     RESPONSE=$(curl -sfSL -H 'Accept: application/json' -H \"x-api-key: $API_KEY\" \"$URL\");     COUNT=$(jq '.data | length' <<<\"$RESPONSE\");     if [[ $COUNT -eq 0 ]]; then         break;     fi;     jq '.data[]' <<<\"$RESPONSE\" >>\"$TEMP\";     PAGES=$((PAGES+1));     if [[ $COUNT -lt $PAGE_SIZE ]]; then         break;     fi; done; OUTPUT='{{$FullRootDir}}curseforge-serverpacks.json'; if [[ ! -s \"$TEMP\" ]]; then     jq -n --arg generatedAt \"$(date -u +%Y-%m-%dT%H:%M:%SZ)\" '{generatedAt:$generatedAt,pageSize:'\"$PAGE_SIZE\"',pagesQueried:'\"$PAGES\"',modpackCount:0,modpacks:[]}' >\"$OUTPUT\";     echo 'CurseForge server pack catalogue saved to curseforge-serverpacks.json (no modpacks matched filters)';     exit 0; fi; jq --slurp --arg generatedAt \"$(date -u +%Y-%m-%dT%H:%M:%SZ)\" --argjson pageSize $PAGE_SIZE --argjson pages $PAGES '(     [ .[]       | select(any((.latestFiles // [])[]?; (.isServerPack == true) or (.serverPackFileId != null)))       | {             id,             name,             slug,             summary,             websiteUrl,             downloadCount,             authors: ((.authors // []) | map(.name)),             latestServerFiles: [                 (.latestFiles // [])[]                 | select((.isServerPack == true) or (.serverPackFileId != null))                 | {                     fileId: (.serverPackFileId // .id),                     displayName,                     downloadUrl,                     fileDate,                     releaseType,                     gameVersions                 }             ]         }     ] ) as $packs | {     generatedAt: $generatedAt,     pageSize: $pageSize,     pagesQueried: $pages,     modpackCount: ($packs | length),     modpacks: $packs }' \"$TEMP\" >\"$OUTPUT\"; echo 'CurseForge server pack catalogue saved to curseforge-serverpacks.json';\""
    },
    {
        "UpdateStageName": "Refresh CurseForge Catalogue",
        "UpdateSourcePlatform": "Windows",
        "UpdateSource": "Executable",
        "UpdateSourceData": "powershell.exe",
        "UpdateSourceArgs": "-NoProfile -Command \"$ErrorActionPreference = 'Stop'; $apiKey = '{{CurseForgeApiKey}}'; if ([string]::IsNullOrWhiteSpace($apiKey)) {     throw 'CurseForge API key is required (CurseForgeApiKey setting).'; } try {     $pageSize = [int]'{{CurseForgePageSize}}';     if ($pageSize -lt 1 -or $pageSize -gt 100) { $pageSize = 50 } } catch { $pageSize = 50 } try {     $maxPages = [int]'{{CurseForgeMaxPages}}';     if ($maxPages -lt 1 -or $maxPages -gt 40) { $maxPages = 5 } } catch { $maxPages = 5 } $modLoader = '{{CurseForgeModLoaderType}}'; $gameVersionType = '{{CurseForgeGameVersionType}}'; $baseUrl = 'https://api.curseforge.com/v1/mods/search?gameId=432&classId=4471&sortOrder=desc'; if (-not [string]::IsNullOrWhiteSpace($gameVersionType) -and $gameVersionType -ne '0') {     $baseUrl += \"&gameVersionTypeId=$gameVersionType\"; } if (-not [string]::IsNullOrWhiteSpace($modLoader) -and $modLoader -ne '0') {     $baseUrl += \"&modLoaderType=$modLoader\"; } $data = [System.Collections.Generic.List[object]]::new(); $pagesFetched = 0; for ($page = 0; $page -lt $maxPages; $page++) {     $url = \"$baseUrl&pageSize=$pageSize&page=$page\";     $response = Invoke-RestMethod -Method Get -Uri $url -Headers @{ 'x-api-key' = $apiKey; 'Accept' = 'application/json' };     if ($null -eq $response.data) { break }     foreach ($item in $response.data) { $data.Add($item) }     $pagesFetched++;     if ($response.data.Count -lt $pageSize) { break } } $modpacks = @(); foreach ($mod in $data) {     $serverFiles = @($mod.latestFiles | Where-Object { $_.isServerPack -eq $true -or $_.serverPackFileId });     if ($serverFiles.Count -eq 0) { continue }     $modpacks += [PSCustomObject]@{         id = $mod.id;         name = $mod.name;         slug = $mod.slug;         summary = $mod.summary;         websiteUrl = $mod.websiteUrl;         downloadCount = $mod.downloadCount;         authors = ($mod.authors | ForEach-Object { $_.name });         latestServerFiles = $serverFiles | ForEach-Object {             [PSCustomObject]@{                 fileId = if ($_.serverPackFileId) { $_.serverPackFileId } else { $_.id };                 displayName = $_.displayName;                 downloadUrl = $_.downloadUrl;                 fileDate = $_.fileDate;                 releaseType = $_.releaseType;                 gameVersions = $_.gameVersions             }         }     } } $result = [PSCustomObject]@{     generatedAt = (Get-Date).ToUniversalTime().ToString('o');     pageSize = $pageSize;     pagesQueried = $pagesFetched;     modpackCount = $modpacks.Count;     modpacks = $modpacks }; $outFile = Join-Path -Path '{{$FullRootDir}}' -ChildPath 'curseforge-serverpacks.json'; $result | ConvertTo-Json -Depth 6 | Set-Content -Path $outFile -Encoding UTF8; Write-Output \"CurseForge server pack catalogue saved to $outFile\";\""
    },
    {
        "UpdateStageName": "Download Selected Server Pack",
        "UpdateSourcePlatform": "Linux",
        "UpdateSource": "Executable",
        "UpdateSourceData": "/bin/bash",
        "UpdateSourceArgs": "-c \"set -euo pipefail; API_KEY='{{CurseForgeApiKey}}'; MOD_ID='{{CurseForgeModpackId}}'; FILE_ID='{{CurseForgeFileId}}'; if [[ -z \"$API_KEY\" ]]; then     echo 'CurseForge API key is required (CurseForgeApiKey setting).' >&2;     exit 1; fi; if [[ -z \"$MOD_ID\" || $MOD_ID == 0 ]]; then     echo 'CurseForgeModpackId must be set to a valid mod ID.' >&2;     exit 1; fi; if [[ -z \"$FILE_ID\" || $FILE_ID == 0 ]]; then     echo 'CurseForgeFileId must be set to a valid file ID.' >&2;     exit 1; fi; mkdir -p Minecraft; cd Minecraft; if [[ '{{CleanBeforeInstall}}' == 'true' ]]; then     find . -mindepth 1 ! -name 'curseforge-serverpacks.json' ! -path './backups' ! -path './backups/*' -exec rm -rf {} +; fi; DOWNLOAD_URL=$(curl -sfSL -H 'Accept: application/json' -H \"x-api-key: $API_KEY\" \"https://api.curseforge.com/v1/mods/$MOD_ID/files/$FILE_ID/download-url\" | jq -r '.data'); if [[ -z \"$DOWNLOAD_URL\" || $DOWNLOAD_URL == null ]]; then     echo 'Failed to retrieve download URL for the selected modpack file.' >&2;     exit 1; fi; echo \"Downloading $DOWNLOAD_URL\"; wget -qO serverpack.zip \"$DOWNLOAD_URL\"; rm -rf serverpack_tmp; mkdir -p serverpack_tmp; unzip -qo serverpack.zip -d serverpack_tmp; SUBDIR='{{ServerPackSubdirectory}}'; shopt -s dotglob; if [[ -n \"$SUBDIR\" && -d serverpack_tmp/$SUBDIR ]]; then     mv serverpack_tmp/$SUBDIR/* .; else     mv serverpack_tmp/* .; fi; shopt -u dotglob; rm -rf serverpack_tmp serverpack.zip; find . -maxdepth 1 -type f -name '*.sh' -exec chmod +x {} + >/dev/null 2>&1 || true; echo 'CurseForge server pack installed.';\""
    },
    {
        "UpdateStageName": "Download Selected Server Pack",
        "UpdateSourcePlatform": "Windows",
        "UpdateSource": "Executable",
        "UpdateSourceData": "powershell.exe",
        "UpdateSourceArgs": "-NoProfile -Command \"$ErrorActionPreference = 'Stop'; $apiKey = '{{CurseForgeApiKey}}'; if ([string]::IsNullOrWhiteSpace($apiKey)) {     throw 'CurseForge API key is required (CurseForgeApiKey setting).'; } $modId = '{{CurseForgeModpackId}}'; if ([string]::IsNullOrWhiteSpace($modId) -or $modId -eq '0') {     throw 'CurseForgeModpackId must be set to a valid mod ID.'; } $fileId = '{{CurseForgeFileId}}'; if ([string]::IsNullOrWhiteSpace($fileId) -or $fileId -eq '0') {     throw 'CurseForgeFileId must be set to a valid file ID.'; } $root = Join-Path -Path '{{$FullRootDir}}' -ChildPath 'Minecraft'; if (-not (Test-Path $root)) {     New-Item -ItemType Directory -Path $root | Out-Null; } Set-Location -Path $root; if ('{{CleanBeforeInstall}}' -eq 'true') {     Get-ChildItem -Force | Where-Object { $_.Name -notin @('curseforge-serverpacks.json','backups') } | Remove-Item -Recurse -Force -ErrorAction SilentlyContinue; } $downloadUrl = Invoke-RestMethod -Method Get -Uri \"https://api.curseforge.com/v1/mods/$modId/files/$fileId/download-url\" -Headers @{ 'x-api-key' = $apiKey; 'Accept' = 'application/json' }; if ([string]::IsNullOrWhiteSpace($downloadUrl.data)) {     throw 'Failed to retrieve download URL for the selected modpack file.'; } Invoke-WebRequest -UseBasicParsing -Uri $downloadUrl.data -OutFile 'serverpack.zip'; if (Test-Path 'serverpack_tmp') {     Remove-Item -Recurse -Force 'serverpack_tmp'; } Expand-Archive -Path 'serverpack.zip' -DestinationPath 'serverpack_tmp' -Force; $subDir = '{{ServerPackSubdirectory}}'; if ([string]::IsNullOrWhiteSpace($subDir)) {     Get-ChildItem -Path 'serverpack_tmp' -Force | ForEach-Object { Move-Item -Path $_.FullName -Destination $root -Force }; } elseif (Test-Path (Join-Path 'serverpack_tmp' $subDir)) {     Get-ChildItem -Path (Join-Path 'serverpack_tmp' $subDir) -Force | ForEach-Object { Move-Item -Path $_.FullName -Destination $root -Force }; } else {     Write-Warning \"Specified ServerPackSubdirectory '$subDir' was not found in the archive; copying full contents instead.\";     Get-ChildItem -Path 'serverpack_tmp' -Force | ForEach-Object { Move-Item -Path $_.FullName -Destination $root -Force }; } Remove-Item -Recurse -Force 'serverpack_tmp'; Remove-Item -Force 'serverpack.zip'; Write-Output 'CurseForge server pack installed.';\""
    },
    {
        "UpdateStageName": "Write EULA",
        "UpdateSourcePlatform": "Linux",
        "UpdateSource": "Executable",
        "UpdateSourceData": "/bin/bash",
        "UpdateSourceArgs": "-c \"mkdir -p Minecraft && cd Minecraft && printf 'eula=%s\\\n' '{{EulaAccepted}}' > eula.txt\""
    },
    {
        "UpdateStageName": "Write EULA",
        "UpdateSourcePlatform": "Windows",
        "UpdateSource": "Executable",
        "UpdateSourceData": "powershell.exe",
        "UpdateSourceArgs": "-NoProfile -Command \"$root = Join-Path -Path '{{$FullRootDir}}' -ChildPath 'Minecraft'; if (-not (Test-Path $root)) {     New-Item -ItemType Directory -Path $root | Out-Null; } $eulaPath = Join-Path -Path $root -ChildPath 'eula.txt'; Set-Content -Path $eulaPath -Value ('eula={{EulaAccepted}}') -Encoding UTF8;\""
    }
]
